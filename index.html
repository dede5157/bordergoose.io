<!DOCTYPE html>
<html>
<head>
  <title>Border Goose alpha</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { font-family: sans-serif; background: #f0f8ff; margin: 0; text-align: center; }
    #game { display: none; position: relative; }
    #zoneLabel {
      position: absolute; top: 10px; left: 10px;
      background: rgba(255,255,255,0.8); padding: 4px 8px;
      border-radius: 4px; font-weight: bold; font-size: 14px;
      pointer-events: none;
    }
    canvas { border: 1px solid #333; background: #fff; display: block; margin: 0 auto; }
    button { margin: 5px; padding: 10px 20px; font-size: 16px; }
    button:disabled { opacity: 0.5; }
    #menu { margin-top: 40px; }
  </style>
</head>
<body>

  <div id="menu">
    <h1>ü™ø Border Goose</h1>
    <p>Select your device:</p>
    <button id="mobileBtn">Mobile</button>
    <button id="desktopBtn">Desktop</button>
  </div>

  <div id="game">
    <div id="zoneLabel"></div>
    <canvas id="gameCanvas"></canvas><br>
    <button id="landBtn">Walk</button>
    <button id="waterBtn">Swim</button>
    <button id="flyBtn">Fly</button>
  </div>

  <script>
  const canvas = document.getElementById("gameCanvas");
  const ctx    = canvas.getContext("2d");
  const zoneLabel = document.getElementById("zoneLabel");

  const gooseImg = new Image();
  gooseImg.src = "Copilot_20250724_235148.png";

  const gooseSize = 40;
  const halfGoose = gooseSize / 2;

  let goose       = { x:0, y:0, mode:"land" };
  let destination = null;
  let currentZone = { x:0, y:0 };
  let zoneMemory  = {};
  const tileSize = 60;
  let gridCols, gridRows;

  const terrainLibrary = {
    Forest: {
      colors: { tree:"#228B22", grass:"#90EE90", path:"#d2b48c" },
      allowedModes: ["land","fly"], logic: forestLogic
    },
    Lake: {
      colors: { water:"#87CEFA", shore:"#A2DFF7" },
      allowedModes: ["water","fly"], logic: lakeLogic
    },
    City: {
      colors: { road:"#A9A9A9", building:"#696969", plaza:"#ccc" },
      allowedModes: ["land"], logic: cityLogic
    },
    Field: {
      colors:{
        corn:"#F4D03F", wheat:"#F5DEB3", grass:"#ADFF2F",
        flower:"#FFD700", path:"#D2B48C", hay:"#DEB887"
      },
      allowedModes:["land","fly"], logic: fieldLogic
    },
    Airport:{
      colors:{ tarmac:"#C0C0C0", light:"#F5F5DC" },
      allowedModes:["land"], logic: airportLogic
    },
    "Surb-1": {
      colors: { road:"#808080", grass:"#7CFC00" },
      allowedModes: ["land","fly"], logic: surb1Logic
    }
  };

  function seededRand(seed){
    let x = Math.sin(seed * 928371.123) * 10000;
    return x - Math.floor(x);
  }

  function buildGrid(typeFn, walkableFn){
    let grid = [];
    for(let y=0; y<gridRows; y++){
      let row = [];
      for(let x=0; x<gridCols; x++){
        let t = typeFn(x,y);
        row.push({ type:t, walkable: walkableFn(t) });
      }
      grid.push(row);
    }
    return grid;
  }

  function randomBiome(){
    const keys = Object.keys(terrainLibrary);
    return keys[Math.floor(Math.random()*keys.length)];
  }

  // --- Biome logic ---
  function forestLogic(sx,sy){ return buildGrid(
    (x,y)=> seededRand(x*31+y*97+sx*173+sy*389)<0.7?"tree":"grass",
    t=> t==="grass"
  );}
  function lakeLogic(sx,sy){ return buildGrid(
    (x,y)=>{
      let cx=gridCols/2, cy=gridRows/2, dx=x-cx, dy=y-cy;
      return Math.sqrt(dx*dx+dy*dy)<5?"water":"shore";
    },
    t=> t==="shore"
  );}
  function cityLogic(sx,sy){ return buildGrid(
    (x,y)=>{
      let r=seededRand(x*13+y*17+sx*59+sy*67);
      return r<0.15?"road":r<0.25?"plaza":"building";
    },
    t=> t==="road"||t==="plaza"
  );}
  function fieldLogic(sx,sy){ return buildGrid(
    (x,y)=>{
      let r=seededRand(x*17+y*23+sx*37+sy*41);
      if((x+y)%11===0&&r<0.6) return "path";
      if(r<0.15) return "hay";
      if(r<0.35) return "corn";
      if(r<0.55) return "wheat";
      if(r<0.75) return "grass";
      if(r<0.9) return "flower";
      return "grass";
    },
    t=> !["corn","wheat","hay"].includes(t)
  );}
  function airportLogic(sx,sy){ return buildGrid(
    (x,y)=>{
      let r=seededRand(x*17+y*23+sx*31+sy*47);
      return (y%5===0&&r<0.8)?"tarmac":"light";
    },
    ()=> true
  );}

  // --- New Suburb map logic ---
  function surb1Logic(sx, sy) {
    const amp   = gridRows/4 * (0.5 + seededRand(sx*123 + sy*456));
    const freq  = (2 * Math.PI) / gridCols;
    const phase = seededRand(sx*789 + sy*321) * 2 * Math.PI;
    const roadW = 2;
    return buildGrid(
      (x, y) => {
        const center = gridRows/2 + amp * Math.sin(freq * x + phase);
        return Math.abs(y - center) <= roadW ? "road" : "grass";
      },
      t => t === "road" || t === "grass"
    );
  }

  // --- UI & start ---
  function startGame(type){
    document.getElementById("menu").style.display = "none";
    document.getElementById("game").style.display = "block";

    const isMobile = (type==="mobile");
    const w = window.innerWidth  - (isMobile?20:0);
    const h = window.innerHeight - (isMobile?160:0);

    gridCols = Math.floor(w/tileSize);
    gridRows = Math.floor(h/tileSize);
    canvas.width  = gridCols * tileSize;
    canvas.height = gridRows * tileSize;

    goose.x = canvas.width/2;
    goose.y = canvas.height/2;
    loadZone(0,0);
    loop();
  }

  function setMode(m){
    const biome = zoneMemory[`${currentZone.x},${currentZone.y}`].biome;
    if(terrainLibrary[biome].allowedModes.includes(m)){
      goose.mode = m;
    }
  }

  document.getElementById("mobileBtn").onclick  = ()=> startGame("mobile");
  document.getElementById("desktopBtn").onclick = ()=> startGame("desktop");
  document.getElementById("landBtn").onclick    = ()=> setMode("land");
  document.getElementById("waterBtn").onclick   = ()=> setMode("water");
  document.getElementById("flyBtn").onclick     = ()=> setMode("fly");

  canvas.addEventListener("click", e=>{
    const r = canvas.getBoundingClientRect();
    destination = { x: e.clientX - r.left, y: e.clientY - r.top };
  });

  function loadZone(x,y){
    const key = `${x},${y}`;
    if(!zoneMemory[key]){
      const biome = randomBiome();
      zoneMemory[key] = { biome, grid: terrainLibrary[biome].logic(x,y) };
    }
    currentZone = { x,y };
    zoneLabel.textContent = zoneMemory[key].biome;
  }

  // --- Detail‚Äêdrawing helpers ---
  function drawTree(px,py){ /* ... */ }
  function drawGrassBlades(px,py,seed){ /* ... */ }
  function drawPathPebbles(px,py,seed){ /* ... */ }
  function drawWaterWaves(px,py,seed){ /* ... */ }
  function drawShoreShells(px,py,seed){ /* ... */ }
  function drawBuildingDetails(px,py,seed){ /* ... */ }
  function drawRoadLines(px,py){ /* ... */ }
  function drawPlazaTiles(px,py){ /* ... */ }
  function drawCornStalks(px,py,seed){ /* ... */ }
  function drawWheatStalks(px,py,seed){ /* ... */ }
  function drawFlower(px,py){ /* ... */ }
  function drawHayDetail(px,py){ /* ... */ }
  function drawTarmacMarkings(px,py){ /* ... */ }
  function drawLights(px,py){ /* ... */ }
  // New detail for suburb roads
  function drawSuburbRoadDetail(px, py) {
    ctx.fillStyle = "#FFD700";
    ctx.fillRect(px + tileSize/2 - 2, py, 4, tileSize);
  }

  // --- Draw loop ---
  function drawTerrain(){
    const zone = zoneMemory[`${currentZone.x},${currentZone.y}`];
    const cols = terrainLibrary[zone.biome].colors;
    ctx.clearRect(0,0,canvas.width,canvas.height);

    for(let y=0; y<gridRows; y++){
      for(let x=0; x<gridCols; x++){
        const tile = zone.grid[y][x];
        const px = x*tileSize, py = y*tileSize;
        ctx.fillStyle = cols[tile.type] || "#fff";
        ctx.fillRect(px,py,tileSize,tileSize);

        const seed = x*31 + y*47 + currentZone.x*97 + currentZone.y*131;
        switch(zone.biome){
          case "Forest":
            if(tile.type==="tree")  drawTree(px,py);
            if(tile.type==="grass") drawGrassBlades(px,py,seed);
            if(tile.type==="path")  drawPathPebbles(px,py,seed);
            break;
          case "Lake":
            if(tile.type==="water") drawWaterWaves(px,py,seed);
            if(tile.type==="shore") drawShoreShells(px,py,seed);
            break;
          case "City":
            if(tile.type==="building") drawBuildingDetails(px,py,seed);
            if(tile.type==="road")     drawRoadLines(px,py);
            if(tile.type==="plaza")    drawPlazaTiles(px,py);
            break;
          case "Field":
            if(tile.type==="corn")   drawCornStalks(px,py,seed);
            if(tile.type==="wheat")  drawWheatStalks(px,py,seed);
            if(tile.type==="flower") drawFlower(px,py);
            if(tile.type==="hay")    drawHayDetail(px,py);
            if(tile.type==="path")   drawPathPebbles(px,py,seed);
            break;
          case "Airport":
            if(tile.type==="tarmac") drawTarmacMarkings(px,py);
            if(tile.type==="light")  drawLights(px,py);
            break;
          case "Surb-1":
            if(tile.type==="grass") drawGrassBlades(px,py,seed);
            if(tile.type==="road")  drawSuburbRoadDetail(px,py);
            break;
        }
      }
    }
  }

  function loop(){
    if(destination){
      let dx=destination.x-goose.x, dy=destination.y-goose.y;
      let d=Math.hypot(dx,dy);
      if(d<2) destination=null;
      else { goose.x+=(dx/d)*3; goose.y+=(dy/d)*3; }
    }

    if(goose.x<halfGoose){
      currentZone.x--; loadZone(currentZone.x,currentZone.y);
      goose.x=canvas.width-halfGoose; destination=null;
    } else if(goose.x>canvas.width-halfGoose){
      currentZone.x++; loadZone(currentZone.x,currentZone.y);
      goose.x=halfGoose; destination=null;
    }
    if(goose.y<halfGoose){
      currentZone.y--; loadZone(currentZone.x,currentZone.y);
      goose.y=canvas.height-halfGoose; destination=null;
    } else if(goose.y>canvas.height-halfGoose){
      currentZone.y++; loadZone(currentZone.x,currentZone.y);
      goose.y=halfGoose; destination=null;
    }

    drawTerrain();
    if(gooseImg.complete){
      ctx.drawImage(
        gooseImg,
        goose.x-halfGoose,
        goose.y-halfGoose,
        gooseSize, gooseSize
      );
    }
    requestAnimationFrame(loop);
  }
  </script>
</body>
</html>
