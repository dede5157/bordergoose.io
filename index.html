<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>border goose</title>
  <style>
    canvas {
      border: 1px solid #333;
      display: block;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const gooseImg = new Image();
    gooseImg.src = "Copilot_20250724_232208.png"; // Place this in your repoâ€™s root or assets folder

    const goose = { x: canvas.width / 2, y: canvas.height / 2, speed: 4 };
    const currentZone = { x: 0, y: 0 };
    let target = { x: goose.x, y: goose.y };

    // ðŸŒ± Seeded PRNG (Mulberry32)
    function mulberry32(seed) {
      let t = seed;
      return function() {
        t += 0x6D2B79F5;
        let r = Math.imul(t ^ (t >>> 15), t | 1);
        r ^= r + Math.imul(r ^ (r >>> 7), r | 61);
        return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
      };
    }

    // ðŸ§­ Zone seed generator
    function zoneSeed(x, y) {
      const prime = 9973;
      return (x * prime + y) % 999999;
    }

    function drawTerrain(xZone, yZone) {
      ctx.fillStyle = "#DFF0B4";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const hue = 120 + (xZone * 10 - yZone * 5);
      ctx.fillStyle = `hsla(${hue}, 50%, 70%, 0.3)`;

      const random = mulberry32(zoneSeed(xZone, yZone));

      for (let i = 0; i < 40; i++) {
        const x = random() * canvas.width;
        const y = random() * canvas.height;
        ctx.beginPath();
        ctx.arc(x, y, 20, 0, 2 * Math.PI);
        ctx.fill();
      }

      ctx.fillStyle = "#333";
      ctx.font = "16px sans-serif";
      ctx.fillText(`Zone [${xZone}, ${yZone}]`, 10, 20);
    }

    function drawGoose() {
      ctx.drawImage(gooseImg, goose.x - 15, goose.y - 15, 30, 30);
    }

    function updateGoose() {
      const dx = target.x - goose.x;
      const dy = target.y - goose.y;
      const dist = Math.hypot(dx, dy);

const landingThreshold = 2;

if (dist > landingThreshold) {
  goose.x += (dx / dist) * goose.speed;
  goose.y += (dy / dist) * goose.speed;
} else {
  goose.x = target.x;
  goose.y = target.y;
}

      const borderMargin = 10;
      let shift = { x: 0, y: 0 };

      if (goose.x < borderMargin) shift.x = -1;
      if (goose.x > canvas.width - borderMargin) shift.x = 1;
      if (goose.y < borderMargin) shift.y = -1;
      if (goose.y > canvas.height - borderMargin) shift.y = 1;

      if (shift.x || shift.y) {
        currentZone.x += shift.x;
        currentZone.y += shift.y;
        goose.x = canvas.width / 2;
        goose.y = canvas.height / 2;
        target.x = goose.x;
        target.y = goose.y;
        drawTerrain(currentZone.x, currentZone.y);
        console.log("Zone updated:", currentZone);
      }
    }

    function gameLoop() {
      updateGoose();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawTerrain(currentZone.x, currentZone.y);
      drawGoose();
      requestAnimationFrame(gameLoop);
    }

    gooseImg.onload = () => {
      drawTerrain(currentZone.x, currentZone.y);
      gameLoop();
    };

    canvas.addEventListener("click", e => {
      const rect = canvas.getBoundingClientRect();
      target.x = e.clientX - rect.left;
      target.y = e.clientY - rect.top;
    });

    canvas.addEventListener("touchstart", e => {
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      target.x = touch.clientX - rect.left;
      target.y = touch.clientY - rect.top;
    });

    // ðŸš« Arrow key movement disabled
    // window.addEventListener("keydown", e => keys[e.key] = true);
    // window.addEventListener("keyup", e => keys[e.key] = false);
  </script>
</body>
</html>
